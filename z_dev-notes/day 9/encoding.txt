added encoding capabilities, write bits function


void write_bits(BinCode bincode, int val, int start_bit, int end_bit)
{
    int i;

    if (start_bit > end_bit)
    {
        /* handle error */
        printf("INVALID: start bit: %d is larger than end bit: %d", start_bit, end_bit);
        return;
    }

    int num_bits = end_bit - start_bit + 1;

    int max_val = (1 << num_bits) - 1;

    if (val > max_val)
    {
        /* handle error */
        printf("INVALID VALUE: %d exceeds max allowed value %d for %d bits\n", val, max_val, num_bits);
        return;
    }
    
    for (i = 0; i < num_bits; i++)
    {
        /* ------------ shift 'val' right by i to bring the i-th bit to position 0, then mask it ------------ */

        int bit_val = (val >> i) & 1;

        _____________________________
        /* example: */     
        /* num_bits = 4 (6-9)*/
        /* 0: val = 13 = 00001101*/
        _____________________________       
        /* 0: bit_val = 13>>0 = 00001101 */
        /* 0: bit val = 1 */
        /* 1: bit_val = 13>>1 = 00000110 */
        /* 1: bit val = 0 */
        /* 2: bit_val = 13>>2 = 00000011 */
        /* 2: bit val = 1 */
        /* 3: bit_val = 13>>3 = 00000001 */
        /* 3: bit val = 1 */

        /* ------------ compute the logical bit number (e.g., 6,7,8...) ------------*/
        int target_bit = start_bit + i; 
        /* 0: 6+0 = 6 */
        /* 1: 6+1 = 7 */
        /* 2: 6+2 = 8 */
        /* 3: 6+3 = 9 */
        /* ------------ convert to array index using inverse_idx, then assign the bit value as '0' or '1' ------------ */
        bincode[inverse_idx(target_bit)] = bit_val ? '1' : '0';
        /* 0: 9-6 = 3 =? bincode=> 0001000000*/
        /* 1: 9-7 = 2 =? bincode=> 0001000000*/
        /* 2: 9-8 = 1 =? bincode=> 0101000000*/
        /* 3: 9-9 = 0 =? bincode=> 1101000000*/
    }
}


using this logic i assemble the opcode bincode step by step:

void encode_opcode(Opcode opcode, AddressingMode src_op_mode, AddressingMode dest_op_mode, EncodedLine *line)
{
    BinCode *bincode = line->words[0];
    
    assemble_AER(bincode, 0);
    assemble_src_op_mod(bincode, src_op_mode);
    assemble_dest_op_mod(bincode, dest_op_mode);
    assemble_opcode(bincode, opcode);
}


** we need to encode now the rest of a line:
    - src operand 
    - dest operand

immediate operand: 8 bits for number + 2 AER bits (LSB) => AER must be A = 00
direct operand: 8 bits for the adress of the label + 2 AER bits (LSB) => could be any of the AER 
mat access: 2 words, -> 1. is label (address + AER)     
                     -> 2. 6-9 bits are row reg, 2-5 are col reg
register: 
    if register is src_op => 6-9 bits is reg_num bits
    if register is dest_op => 2-5 bits are reg_num bits 
    if register is --both-- => than there is only 1 added word  2-5 bits are dest_reg_num bits 
                                                                6-9 bits is src_reg_num bits