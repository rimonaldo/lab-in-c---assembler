תבנית לסיכום ותיעוד באג - [נא למלא שם הפרויקט/מודול]
תאריך: 27.06.2025

1. תקציר הבאג:
התוכנית קרסה באופן עקבי עם שגיאת Segmentation Fault בפונקציה printf, לאחר קריאה לכאורה תקינה לפונקציה strdup. הבעיה התגלתה כתוצאה עקיפה של שחיתות זיכרון (Heap Corruption) ולא ככשל ישיר של הפונקציות המעורבות.

2. תיאור הסימפטום:

התנהגות: קריסה מוחלטת של התוכנית עם הודעת DEADLYSIGNAL מה-AddressSanitizer.

מיקום מדויק: קובץ first_pass.c, פונקציה parse_operand, בקוורה [...] (השורה של ה-printf).

מידע מה-Sanitizer: הכלי דיווח על ניסיון קריאה מכתובת נמוכה (zero page), מה שהצביע על שימוש במצביע NULL שהועבר ל-printf עם פורמט %s.

3. תהליך האבחון (מה ניסינו ומה למדנו):
תהליך הדיבאגינג התבסס על אלימינציה שיטתית של חשודים:

חשד ראשון: דליפת זיכרון מסיבית.

פעולה: זיהוי ותיקון דליפה שנגרמה על ידי memset מיותר על ASTNode חדש.

תוצאה: הבעיה נמשכה, ולכן נשלל קשר ישיר בין הדליפה לקריסה.

חשד שני: לוגיקה שגויה בטיפול בתוויות (Dangling Pointer).

פעולה: כל הקוד שקשור ל-is_label_declare ו-table_insert הוכנס להערה.

תוצאה: הבעיה נמשכה, ולכן נשלל קשר לטבלת הסמלים.

חשד שלישי: גלישת חוצץ במחסנית (Stack Overflow).

פעולה: זיהוי ותיקון לולאה לא בטוחה בפונקציה is_valid_mat_access.

תוצאה: הבעיה נמשכה, מה שהצביע על כך שזה לא היה הגורם לקריסה הספציפית הזו.

פריצת דרך: בדיקה מבודדת (MRE - Minimal, Reproducible Example).

פעולה: יצירת תוכנית test.c שבודקה רק את הטוקנייזר ו-strdup.

תוצאה: התוכנית המבודדת עבדה בהצלחה. זה הוכיח שהרכיבים עצמם תקינים והבעיה היא אינטראקציה עם חלק אחר בקוד המלא.

אימות סופי: החלפת strdup במימוש אישי (my_strdup).

פעולה: נכתבה פונקציה my_strdup שהחליפה את קריאת הספרייה המקורית.

תוצאה: התוכנית הפסיקה לקרוס.

4. ניתוח שורש הבעיה (Root Cause Analysis):
ההצלחה של my_strdup הוכיחה שהבעיה הייתה שחיתות בערימה (Heap Corruption).

הנזק: חלק אחר של הקוד (שכנראה עוד לא זיהינו במפורש, אך חשוד עיקרי הוא [...] בקובץ [...]) גרם נזק למבני הנתונים הפנימיים של מנגנון הקצאת הזיכרון.

התגובה: strdup הסטנדרטי (במיוחד עם ASan) זיהה את השחיתות ו"סירב" לעבוד כדי למנוע נזק נוסף, ולכן החזיר NULL.

הקריסה: my_strdup הפשוט יותר לא ביצע את אותן בדיקות, "דילג" מעל הנזק והצליח להקצות זיכרון, ובכך מנע את העברת ה-NULL ל-printf.

5. פתרון ותיקונים:

פתרון מיידי: שימוש בפונקציה my_strdup כמעקף (Workaround) שעוקף את הרגישות של strdup הסטנדרטי לשחיתות.

תיקונים מרכזיים נוספים:

הסרת memset שגרם לדליפת זיכרון.

הוספת בדיקת גבולות ב-is_valid_mat_access.

הוספת לוגיקה לניהול רשימת ה-AST (head/tail).

[...] (רשום כאן תיקונים נוספים).

6. משימות להמשך:
למרות שהתוכנית עובדת, נותרו מספר משימות "ניקיון" כדי להפוך אותה לנכונה ב-100%:

טיפול בדליפות הזיכרון: להוסיף קריאות ל-free_ast(head) ולפונקציית שחרור לטבלת הסמלים בסוף התוכנית, כדי לטפל בכל הדליפות ש-LeakSanitizer מצא.

איתור ותיקון מקור השחיתות: לאתר את הבאג המקורי שגורם לשחיתות (למשל, free על ערך שאינו מצביע בקובץ ast.c) כדי שניתן יהיה לחזור להשתמש בבטחה ב-strdup המקורי.

בדיקות קוד כלליות: לתקן באגים לוגיים קטנים שנותרו, כמו הלולאה בפונקציה is_valid_label_name שלא בודקת את התו האחרון.